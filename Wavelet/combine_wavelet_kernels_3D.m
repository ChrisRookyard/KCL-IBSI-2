function waveletFilters = combine_wavelet_kernels_3D(Fa,Fd)

% *************************************************************************
% COMBINE_WAVELET_KERNELS_3D: makes a 3D kernel from 2 input wavelets
% *************************************************************************
%
% INPUTS
%
%   Fa and Fd, the approximation and detail filters, respectively
%
% OUTPUTS
%
%   waveletFilters, a cell with an entry for each combination
%   of filters (8), and each entry for that will be 4-D, with the rotations
%   going along the 4th dimension within each cell entry. 
%
% *************************************************************************
%
% By Chris Rookyard, Cancer Imaging Dept., King's College London
% 
% *************************************************************************

% initialise output
waveletFilters = cell(8,1);

% arrange the wavelets in the 8 possible combinations they could go for one
% rotation
waveletOrder = {...
    [Fa;Fa;Fa];...
    [Fa;Fa;Fd];...
    [Fa;Fd;Fa];...
    [Fd;Fa;Fa];...
    [Fa;Fd;Fd];...
    [Fd;Fa;Fd];...
    [Fd;Fd;Fa];...
    [Fd;Fd;Fd]};

% for each of the above, do the 24 possible orientations
for i = 1:8
    
    % prepare the current filters
    og1 = waveletOrder{i}(1,:);
    og2 = waveletOrder{i}(2,:);
    og3 = waveletOrder{i}(3,:);
    jg1 = fliplr(og1);
    jg2 = fliplr(og2);
    jg3 = fliplr(og3);
    
    % organise them in their 24 positions
    g = cat(3,...
        [og1; og2;  og3],...
        [jg3; og2;  og1],...
        [jg1; og2;  jg3],...
        [og3; og2;  jg1],...
        [og2; og3;  og1],...
        [og2; jg3;  jg1],...
        [og2; jg1;  og3],...
        [jg1; jg2;  og3],...
        [jg2; og1;  og3],...
        [jg3; jg1;  og2],...
        [jg3; jg2;  jg1],...
        [jg3; og1;  jg2],...
        [jg2; jg1;  jg3],...
        [og1; jg2;  jg3],...
        [og2; og1;  jg3],...
        [og3; jg1;  jg2],...
        [og3; jg2;  og1],...
        [og3; og1;  og2],...
        [jg1; og3;  og2],...
        [jg2; og3;  jg1],...
        [og1; og3;  jg2],...
        [jg1; jg3;  jg2],...
        [jg2; jg3;  og1],...
        [og1; jg3;  og2]);
    
    % loop over the 24 combinations, and make a 3D kernel from each
    % temporary holder for each iteration
    theseOrnts = zeros(length(Fa),length(Fa),length(Fa),24);
    for k = 1:24
        
        % first outer product, gives a 2D result
        % whichever kernel is "top" should go parallel to x axis
        kernel2D = g(2,:,k)' * g(1,:,k);
        
        % second outer product, gives a 3D result in a roundabout way
        kernel3D = zeros(size(kernel2D,1),size(kernel2D,2),size(kernel2D,2));
        for m = 1:size(kernel2D,2)
            kernel3D(:,:,m) = kernel2D(:,m) * g(3,:,k);
        end

        % with a permutation to orient kernel as expected
        kernel3D = permute(kernel3D,[1,3,2]);
        
        % add to the temporary array
        theseOrnts(:,:,:,k) = kernel3D;
        
    end
    
    waveletFilters{i,1} = theseOrnts;
    
end
